# Линал v1

### К чему эта задача

Классическая задача из мира ООП. На данный момент в 4-х частях, продолжение следует.

Начинается с очень базовых вещей, практически дословно разобранных в лекциях - создаём класс простого вектора в 2D (ещё и с целочисленными координатами), задаём для него поведение оператора ==, упаковывая таким образом логику класса внутрь класса (да, это называется инкапсуляция).

Но уже во 2-й части возникают не очень банальные моменты. И чем дальше - тем страньше. На данный момент задача проходится по большому количеству технических нюансов структуры классов, операторов, модификаторов доступа.

Задача на первый взгляд скучная, но крайне рекомендуется к честному живому решению - сперва вгоняет в страх перед С++ в целом и отдельно перед загадочной руганью компилятора, потом избавляет от страха и приводит к просветлению.


### Часть 1

Реализуйте класс вектора в двумерном пространстве. Публичная часть:
```cpp
class Vector2D
{
public:
    // Конструктор, сразу указываем x и y
    Vector2D(int x, int y);
    // Деструктор (если нужен)
    ~Vector2D();

    // Получение x и y (самих полей в публичной части быть не должно)
    int getX();
    int getY();

    // Перегруженный оператор - сравнение двух векторов на равенство
    bool operator== (const Vector2D& v2);
};

// Перегруженный оператор, вывод вектора в формате (1; 1)
std::ostream& operator<<(std::ostream& os, Vector2D& v);
```

Ожидается, что класс позволит выполнить примерно такой код:
```cpp
    Vector2D v1(1, 1);
    Vector2D v2(2, 2);
    Vector2D v3(1, 1);
    cout << v1 << endl;
    cout << (v1 == v2) << endl;
    cout << (v1 == v3) << endl;
```

И на экране после этого будет:
```
(1; 1)
0
1
```

##### Файлы к части 1

В этой папке лежит vector\_task\_01.cpp. Это заготовка, в которую нужно вписать свой класс.


### Часть 2

Допилите класс вектора в двумерном пространстве до вот такого вида публичной части:
```cpp
class Vector2D
{
public:
    // Тут всё без изменений
    Vector2D(int x, int y);
    ~Vector2D();
    int getX();
    int getY();
    bool operator== (const Vector2D& v2);

    // Ещё один перегруженный оператор - да, он отдельный
    // Хинт - настоящие джедаи смогут для != использовать уже написанное ==
    bool operator!= (const Vector2D& v2);

    // Сумма двух векторов, исходные вектора не меняются, возвращается новый вектор
    Vector2D operator+ (const Vector2D& v2);
};

// Тоже без изменений
std::ostream& operator<<(std::ostream& os, Vector2D& v);
```

Ожидается, что класс позволит выполнить примерно такой код:
```cpp
    Vector2D v1(1, 1);
    Vector2D v2(2, 2);
    Vector2D v3 = v1 + v2; 
    cout << v3 << endl;
    cout << (v1 == v2) << endl;
    cout << (v1 != v2) << endl;
```

И на экране после этого будет:
```
(3; 3)
0
1
```

##### Файлы к части 2

В этой папке лежит vector\_task\_02.cpp. Это заготовка, в которую нужно вписать свой класс.


### Часть 3

Допилите класс вектора в двумерном пространстве до вот такого вида публичной части:
```cpp
class Vector2D
{
public:
    // Тут всё без изменений
    Vector2D(int x, int y);
    ~Vector2D();

    // Теперь getter-ы получили модификатор const. Их код можно оставить как был, он будет работать.
    // Можно решить и без const. Но тогда некоторые логичные варианты решения внезапно откажутся работать.
    // Так как подробного разбора const-ов в разных местах кода ещё не было, на сейчас просто добавьте его.
    // Подробности будут на лекции 26-го марта.
    int getX() const;
    int getY() const;

    // Тут всё без изменений
    bool operator== (const Vector2D& v2);
    bool operator!= (const Vector2D& v2);
    Vector2D operator+ (const Vector2D& v2);

    // Оператор умножения вектора на скаляр
    Vector2D operator* (const int a);
};

// Тут всё без изменений
std::ostream& operator<<(std::ostream& os, Vector2D& v);

// Оператор умножения скаляра на вектор
Vector2D operator* (int a, const Vector2D& v);
// Неожиданно, правда? Умножение скаляра на вектор - это отдельный оператор, он тоже нужен.
// И да, с ним будут нюансы, нужно будет отдельно хорошо подумать - это нормально, так должно быть.
```

Ожидается, что класс позволит выполнить примерно такой код:
```cpp
    Vector2D v1(1, 1);
    Vector2D v2(2, 2);
    Vector2D v3 = v1 * 42;
    cout << v3 << endl;
    Vector2D v4 = 42 * v1;
    cout << v4 << endl;
```

И на экране после этого будет:
```
(42; 42)
(42; 42)
```

##### Файлы к части 3

В этой папке лежит vector\_task\_03.cpp. Это заготовка, в которую нужно вписать свой класс.


### Часть 4

Научим наш вектор читаться из cin. Публичная часть приходит вот к такому виду:
```cpp
class Vector2D
{
public:
    // Добавляем конструктор без параметров
    Vector2D();

    // Тут всё без изменений
    Vector2D(int x, int y);
    ~Vector2D();
    int getX() const;
    int getY() const;

    // Добавляем setter'ы - установка x и y (самих полей в публичной части быть не должно)
    void setX(int x);
    void setY(int y);

    // Тут всё без изменений
    bool operator== (const Vector2D& v2);
    bool operator!= (const Vector2D& v2);
    Vector2D operator+ (const Vector2D& v2);
    Vector2D operator* (const int a);
};

// Тут всё без изменений
std::ostream& operator<<(std::ostream& os, Vector2D& v);
Vector2D operator* (int a, const Vector2D& v);

// Чтение вектора, пусть будет просто две координаты без хитростей
std::istream& operator>>(std::istream &is, Vector2D &v);
```

Ожидается, что класс позволит выполнить примерно такой код:
```cpp
    Vector2D v;
    cin >> v;
    cout << v << endl;
```

И на экране после этого будет:
```
1        <-- Это ввод с клавиатуры
2        <-- Это тоже
(1; 2)   <-- Это вывод считанного вектора в cout
```

##### Файлы к части 4

В этой папке лежит vector\_task\_04.cpp. Это заготовка, в которую нужно вписать свой класс.
