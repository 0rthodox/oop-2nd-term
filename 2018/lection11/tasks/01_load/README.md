# Балансировка нагрузки

### К чему эта задача

Задача на критичный минимум STL. Даже если его не хочется использовать в своём коде, нужно не впадать в ступор, когда на вход данные приходят в STL-ных контейнерах.


### Легенда

Пишем нечто смутно похожее на балансировщик нагрузки на многопроцессорную систему. Балансировать пока что не умеет, умеет только анализировать текущую картину.

Считаем, что в системе одновременно выполняется множество процессов, каждый из которых выполняется строго на одном ядре процессора, нагрузку от каждого можно характеризовать одной цифрой с логическим смыслом "вычислительная сложность задачи" *(в реальной жизни всё гораздо сложнее, но нам для примера пойдёт)*.

Архитектурно предполагается, что наш балансировщик просыпается раз в N миллисекунд, просматривает текущую ситуацию с задачами на выполнение, считает по ней нагрузку на ядра процессора. До следующего просыпания и анализа планировщик считает картину статичной *(что, разумеется, не соответствует действительности, ну да и ладно)*.

### Постановка задачи

Каждый процесс в системе описывается вот таким классом:

```cpp
class Task
{
protected:
    int cpuNum;
    int size;

public:
    Task(int cpuNum, int size) {
        this->cpuNum = cpuNum;
        this->size = size;
    }

    // На каком ядре процессора выполняется задача
    int getCPU() const {
        return cpuNum;
    }

    // Оценка сложности задачи (в попугаях)
    int getSize() const {
        return size;
    }
};
```

Напишите класс планировщика вот с таким прототипом:

```cpp
class Balancer
{
public:
    Balancer();

    // Проанализировать текущие задачи
    void analyze(const vector<Task>& tasks);

    // Сообщить общую нагрузку на заданное ядро
    int getLoadForCPU(int cpuNum);
};
```

Метод analyze получает на вход вектор с описанием всех текущих задач в системе и выполняет его анализ. После выполненного анализа метод getLoadForCPU по номеру ядра процессора сообщает текущую нагрузку на него (считается как сумма сложностей всех процессов на данном ядре).


Пример ожидаемого сценария работы всей конструкции:
```cpp
    vector<Task> data = { {0, 1}, {1, 10}, {0, 6}, {2, 12}, {3, 5} };
    Balancer b;
    b.analyze(data);
    for(unsigned i = 0; i < 4; i++)
        cout << b.getLoadForCPU(i) << endl;
```

Должно напечатать текущую нагрузку на четырёх ядрах:
```
7
10
12
5
```

### Файлы к задаче

В этой папке лежит load\_task.cpp. Это заготовка, в которую нужно вписать свой класс.
